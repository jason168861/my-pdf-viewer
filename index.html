<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF 預覽器 (效能優化版)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
    
    <style>
        /* --- CSS 樣式與原版相同，此處省略 --- */
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: Arial, sans-serif; background-color: #525659; }
        body { display: flex; flex-direction: column; }
        #top-bar { background-color: #333; color: white; padding: 8px 16px; display: flex; align-items: center; flex-shrink: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.4); z-index: 10; }
        #upload-container { display: flex; align-items: center; }
        #upload-button { padding: 6px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
        #upload-button:hover { background-color: #0056b3; }
        #file-name { margin-left: 12px; color: #ccc; font-size: 14px; }
        #zoom-controls { margin-left: auto; display: flex; align-items: center; }
        #zoom-controls button { font-size: 16px; font-weight: bold; width: 32px; height: 32px; margin: 0 5px; border: 1px solid #555; background-color: #444; color: white; border-radius: 4px; cursor: pointer; }
        #zoom-controls button:hover { background-color: #555; }
        #zoom-percent { min-width: 50px; text-align: center; }
        #pdf-viewer { flex-grow: 1; overflow-y: auto; text-align: center; padding: 20px 0; transition: background-color 0.3s; }
        #pdf-viewer.drag-over { background-color: #3e6d8e; border: 4px dashed #fff; }
        .page-container { position: relative; margin: 0 auto 16px auto; box-shadow: 0 4px 8px rgba(0,0,0,0.2); background-color: white; } /* 加上背景色避免透明 */
        .page-container canvas, .page-container .textLayer { position: absolute; top: 0; left: 0; }
        .textLayer { line-height: 1; }
        .textLayer > span { color: transparent; position: absolute; white-space: pre; cursor: text; transform-origin: 0% 0%; }
        ::selection { background: rgba(0, 0, 255, 0.3); }
    </style>
</head>
<body>

    <div id="top-bar">
        <div id="upload-container">
            <input type="file" id="pdf-upload" accept="application/pdf" style="display: none;">
            <button id="upload-button">選擇檔案</button>
            <span id="file-name">尚未選擇檔案</span>
        </div>
        <div id="zoom-controls">
            <button id="zoom-out">-</button>
            <span id="zoom-percent">100%</span>
            <button id="zoom-in">+</button>
        </div>
    </div>

    <div id="pdf-viewer">
        <p style="color: white; padding: 40px; border: 2px dashed #888; display: inline-block;">
            點擊「選擇檔案」或將 PDF 拖曳至此
        </p>
    </div>

<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;

    let currentPdf = null;
    let currentScale = 1.5;
    let isRendering = false; // 【新】渲染狀態旗標，防止重複觸發

    const viewer = document.getElementById('pdf-viewer');
    const uploadInput = document.getElementById('pdf-upload');
    const uploadButton = document.getElementById('upload-button');
    const fileNameSpan = document.getElementById('file-name');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomPercentSpan = document.getElementById('zoom-percent');

    // --- 【優化】檔案處理 ---
    async function loadFile(file) {
        if (!file || file.type !== 'application/pdf') {
            alert('請上傳 PDF 格式的檔案！');
            return;
        }

        fileNameSpan.textContent = file.name;
        viewer.innerHTML = '<p style="color: white;">正在載入檔案...</p>';
        
        try {
            const fileData = await file.arrayBuffer();
            const pdfDoc = await pdfjsLib.getDocument(new Uint8Array(fileData)).promise;
            currentPdf = pdfDoc;
            await setupViewer(); // 改為呼叫 setupViewer
        } catch (error) {
            console.error('載入 PDF 時發生錯誤:', error);
            fileNameSpan.textContent = '檔案載入失敗';
            viewer.innerHTML = `<p style="color: red;">抱歉，無法載入此 PDF 檔案。</p>`;
        }
    }
    
    // --- 【新】建立 PDF 頁面結構 ---
    async function setupViewer() {
        if (!currentPdf) return;

        viewer.innerHTML = ''; // 清空
        updateZoomDisplay();

        // 只建立頁面的容器 (div)，但不立即渲染 canvas
        for (let i = 1; i <= currentPdf.numPages; i++) {
            const page = await currentPdf.getPage(i);
            const viewport = page.getViewport({ scale: currentScale });
            
            const pageContainer = document.createElement('div');
            pageContainer.className = 'page-container';
            pageContainer.id = `page-container-${i}`;
            pageContainer.style.width = `${viewport.width}px`;
            pageContainer.style.height = `${viewport.height}px`;

            // 【新】使用 data-* 屬性儲存頁碼，方便後續渲染
            pageContainer.dataset.pageNumber = i;
            pageContainer.dataset.rendered = "false";

            viewer.appendChild(pageContainer);
        }
        
        // 首次載入時，渲染可視區域的頁面
        renderVisiblePages();
    }

    // --- 【優化】核心渲染邏輯：只渲染可視頁面 ---
    async function renderVisiblePages() {
        if (isRendering || !currentPdf) return;
        isRendering = true;

        const pageContainers = viewer.querySelectorAll('.page-container');
        const viewerRect = viewer.getBoundingClientRect();

        const renderPromises = [];

        for (const container of pageContainers) {
            const containerRect = container.getBoundingClientRect();

            // 判斷頁面是否在可視範圍內 (加上一些緩衝區，提前渲染)
            const isVisible = (containerRect.top < viewerRect.bottom + 500) && (containerRect.bottom > viewerRect.top - 500);

            if (isVisible && container.dataset.rendered === "false") {
                 container.dataset.rendered = "true"; // 標記為正在渲染
                 const pageNum = parseInt(container.dataset.pageNumber, 10);
                 
                 renderPromises.push(renderPage(pageNum));
            }
        }
        
        await Promise.all(renderPromises);
        isRendering = false;
    }

    // --- 【新】單頁渲染函式 ---
    async function renderPage(pageNum) {
        const page = await currentPdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: currentScale });
        const pageContainer = document.getElementById(`page-container-${pageNum}`);

        // 確保容器存在
        if (!pageContainer) return;
        
        // 清空舊的 canvas 和 textLayer (如果有)
        pageContainer.innerHTML = ''; 

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        pageContainer.appendChild(canvas);

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        pageContainer.appendChild(textLayerDiv);
        
        // 渲染 Canvas
        await page.render({ canvasContext: context, viewport }).promise;

        // 渲染文字層 (用於選取)
        const textContent = await page.getTextContent();
        await pdfjsLib.renderTextLayer({
            textContent,
            container: textLayerDiv,
            viewport,
            textDivs: []
        }).promise;
    }

    function updateZoomDisplay() {
        zoomPercentSpan.textContent = `${Math.round(currentScale * 100)}%`;
    }

    // --- 【優化】縮放函式 ---
    async function handleZoom(newScale, focusPoint = null) {
        if (!currentPdf || isRendering) return;

        // 儲存縮放前的狀態
        const viewerRect = viewer.getBoundingClientRect();
        const focusY = focusPoint ? focusPoint.y - viewerRect.top : viewerRect.height / 2;
        const scrollTopBefore = viewer.scrollTop;
        const scrollHeightBefore = viewer.scrollHeight;
        const scrollRatio = scrollHeightBefore > 0 ? (scrollTopBefore + focusY) / scrollHeightBefore : 0;
        
        currentScale = newScale;
        isRendering = true;
        
        updateZoomDisplay();

        // 【核心優化】更新所有頁面容器的尺寸，並將它們標記為未渲染
        const updatePromises = [];
        for (let i = 1; i <= currentPdf.numPages; i++) {
            updatePromises.push((async () => {
                const page = await currentPdf.getPage(i);
                const viewport = page.getViewport({ scale: currentScale });
                const pageContainer = document.getElementById(`page-container-${i}`);
                if (pageContainer) {
                    pageContainer.style.width = `${viewport.width}px`;
                    pageContainer.style.height = `${viewport.height}px`;
                    pageContainer.dataset.rendered = "false"; // 重設渲染標記
                    pageContainer.innerHTML = ''; // 清空內容，等待重新渲染
                }
            })());
        }
        await Promise.all(updatePromises);

        // 根據縮放焦點，計算並設定新的捲動位置
        const scrollHeightAfter = viewer.scrollHeight;
        viewer.scrollTop = (scrollHeightAfter * scrollRatio) - focusY;
        viewer.scrollLeft = (viewer.scrollWidth - viewer.clientWidth) / 2;
        
        isRendering = false; // 解除鎖定
        renderVisiblePages(); // 僅渲染可視區域
    }
    
    // --- 事件監聽 ---
 uploadButton.addEventListener('click', () => uploadInput.click());
    uploadInput.addEventListener('change', (e) => loadFile(e.target.files[0]));

    // 拖曳檔案事件
    viewer.addEventListener('dragover', (e) => { e.preventDefault(); viewer.classList.add('drag-over'); });
    viewer.addEventListener('dragleave', () => viewer.classList.remove('drag-over'));
    viewer.addEventListener('drop', (e) => {
        e.preventDefault();
        viewer.classList.remove('drag-over');
        loadFile(e.dataTransfer.files[0]);
    });
    
    // 節流 (Throttle) 函式 (保持不變)
    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }
    
    // 【新】建立一個被節流的縮放處理函式
    const throttledZoomHandler = throttle((e) => {
        const newScale = e.deltaY > 0 ? currentScale *0.75 : currentScale *1.25;
        // 限制縮放範圍
        if (newScale >= 0.2 && newScale <= 8) {
             handleZoom(newScale, { y: e.clientY });
        }
    }, 50); // 50ms 節流，保持縮放流暢

    // 【新】完全接管滾輪事件，解決瀏覽器意外縮放問題
    viewer.addEventListener('wheel', (e) => {
        // 1. 無論如何，都先阻止瀏覽器的預設行為 (捲動或縮放頁面)
        e.preventDefault();

        // 2. 判斷使用者意圖
        if (e.ctrlKey || e.metaKey) {
            // 如果按下 Ctrl/Cmd，執行我們節流過的縮放函式
            throttledZoomHandler(e);
        } else {
            // 否則，手動控制 viewer 的捲動
            // e.deltaY 代表滾輪垂直滾動的距離
            viewer.scrollTop += e.deltaY;
        }
    }, { passive: false }); // passive: false 是讓 preventDefault() 生效的關鍵

    // 按鈕點擊事件 (保持不變)
    zoomInBtn.addEventListener('click', () => {
        const newScale = currentScale + 0.25;
        if (newScale <= 8.0) handleZoom(newScale);
    });

    zoomOutBtn.addEventListener('click', () => {
        const newScale = currentScale - 0.25;
        if (newScale >= 0.2) handleZoom(newScale);
    });

    // 監聽滾動事件，以渲染新出現的頁面 (保持不變)
    viewer.addEventListener('scroll', throttle(renderVisiblePages, 150));

</script>
</body>
</html>
